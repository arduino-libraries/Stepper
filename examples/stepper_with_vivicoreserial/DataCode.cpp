// This code name is stepperwithvivicoreserial
// Generated by VIVIWARE developer v1.3.0 on https://dev.developer.viviware.com/hard/4158
// Generated at 2022/9/13 21:58:02
//
// Copyright (C) 2022 Takashi Ando
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
// USA.

////////////////////////////////////////////////////////////////////////////////
// AUTO GENERATED CODE
// (You can customize them if familiar with VivicoreSerial library spec)
////////////////////////////////////////////////////////////////////////////////

#include "DataCode.h"

void dump(const uint8_t *data, const size_t data_len) {
  for (size_t i = 0; i < data_len; i++) {
    char c[2] = {};
    for (size_t j = 0; j < sizeof(c); j++) {
      const uint8_t bits = (data[i] >> (j * 4)) & 0x0F;
      c[j] = (bits < 0x0A) ? (char)('0' + bits) : (char)('A' + bits - 0x0A);
    }
    DBG_SERIAL_INSTANCE.print(c[1]);
    DBG_SERIAL_INSTANCE.print(c[0]);
    DBG_SERIAL_INSTANCE.print(" ");
  }
  DBG_SERIAL_INSTANCE.println("");
}

boolean timeout(const uint32_t msec) {
  const unsigned long now = millis();
  static unsigned long prev = 0;
  boolean ret = false;

  if (now - prev > msec) {
    ret = true;
    prev = now;
  }

  return ret;
}

boolean initializeLibrary(const uint16_t version) {
  // Unique branch type ID
  const uint32_t branch_type = 4158;  // 0x0000103E
  static const dcInfo_t dc_info[] = {
    // {group_no, data_nature, data_type, data_min, data_max, data_ini}
    { DcGroup_t::DC_GROUP_1,          DcNature_t::DC_NATURE_IN,  DcType_t::DC_TYPE_BOOLEAN,       0,      1,     0, },  // Group: Controller, Data Code 1: On
    { DcGroup_t::DC_GROUP_1,          DcNature_t::DC_NATURE_IN,  DcType_t::DC_TYPE_ANALOG_2BYTES, 0,      512,   0, },  // Group: Controller, Data Code 2: Speed [pps]
    { DcGroup_t::DC_GROUP_1,          DcNature_t::DC_NATURE_IN,  DcType_t::DC_TYPE_ANALOG_2BYTES, -32767, 32767, 0, },  // Group: Controller, Data Code 3: Steps
    { DcGroup_t::DC_GROUP_1,          DcNature_t::DC_NATURE_OUT, DcType_t::DC_TYPE_BOOLEAN,       0,      1,        },  // Group: Controller, Data Code 4: Moving
  };

  DBG_SERIAL_INSTANCE.begin(HW_SERIAL_BAUD);
  const bool success = Vivicore.begin(branch_type, version, dc_info, countof(dc_info));
  if (!success) {
    DBG_SERIAL_INSTANCE.println("Vivicore.begin() failed");
  }
  return true;
}

receiveStruct receiveFromApp(void) {
  static receiveStruct values = {};
  const AvailableNum_t cnt = Vivicore.available();

  if (DEBUG_PACKET && (cnt.raw > 0)) {
    const RawData_t raw = Vivicore.readRaw();
    if (raw.success) {
      dump(raw.data, raw.data_len);
    }
  }

  for (int i = 0; i < cnt.scaler; i++ ) {
    const ScalerData_t scaler = Vivicore.read();
    const uint8_t data_code = scaler.dc_n;

    if (!scaler.success) {
      DBG_SERIAL_INSTANCE.println("Vivicore.read() failed");
    }

    if (data_code == 1) {  // Group: Controller, Name: On
      const boolean data = (boolean)scaler.data;
      if (values.val_dc1 != data) {
        values.val_dc1 = data;
      }
    } else if (data_code == 2) {  // Group: Controller, Name: Speed [pps]
      const int16_t data = (int16_t)scaler.data;
      if (values.val_dc2 != data) {
        values.val_dc2 = data;
      }
    } else if (data_code == 3) {  // Group: Controller, Name: Steps
      const int16_t data = (int16_t)scaler.data;
      if (values.val_dc3 != data) {
        values.val_dc3 = data;
      }
    } else {
      DBG_SERIAL_INSTANCE.print("DC");
      DBG_SERIAL_INSTANCE.print(data_code);
      DBG_SERIAL_INSTANCE.println(" is unknown");
    }
  }

  return values;
}

void sendToApp(const sendStruct cur_vals) {
  static boolean force = true;
  static sendStruct prev_vals = {};

  if (force || (prev_vals.val_dc4 != cur_vals.val_dc4)) {
    prev_vals.val_dc4 = cur_vals.val_dc4;
    const bool success = Vivicore.write(4, (int32_t)cur_vals.val_dc4);
    if (!success) {
      DBG_SERIAL_INSTANCE.println("Vivicore.write() failed at DC4");
    }
  }
  force = false;

  Vivicore.flush();
}
